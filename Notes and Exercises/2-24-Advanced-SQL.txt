OUTER JOIN ESSENTIALS
    LEFT OUTER JOIN: keep everytihng from the left table even if the right has no matches (nulls fill gaps) 
    RIGHT OUTER JOIN: ^
    FULL OUTER JOIN: keep every row from both (match when possible, null if not) 

Ex: 
show me all users with their sessions, including those without sessions
SELECT
  u.user_id,
  u.user_username,
  u.user_email,
  s.ses_token,
  s.ses_createdat,
  s.ses_expiresat,
  s.ses_eventtype,
  s.ses_caller_ip
FROM users u
LEFT JOIN sessions s
  ON u.user_id = s.user_id
ORDER BY u.user_id, s.ses_createdat DESC;

show me all users with their sessions, including those without sessions. Use NVL to show 'N/A' for missing tokens
SELECT
  u.user_id,
  u.user_username,
  u.user_email,
  NVL(s.ses_token, 'N/A') AS ses_token,
  s.ses_createdat,
  s.ses_expiresat,
  s.ses_eventtype,
  s.ses_caller_ip
FROM users u
LEFT JOIN sessions s
  ON u.user_id = s.user_id
ORDER BY u.user_id, s.ses_createdat DESC;

show me all users with their sessions, including those without sessions. Use COALESCE to show 'N/A' for missing tokens
SELECT
  u.user_id,
  u.user_username,
  u.user_email,
  COALESCE(s.ses_token, 'N/A') AS ses_token,
  s.ses_createdat,
  s.ses_expiresat,
  s.ses_eventtype,
  s.ses_caller_ip
FROM users u
LEFT JOIN sessions s
  ON u.user_id = s.user_id
ORDER BY u.user_id, s.ses_createdat DESC;

list all users and their accounts, including users without accounts
SELECT
  u.user_id,
  u.user_username,
  u.user_email,
  a.*
FROM users u
LEFT JOIN accounts a
  ON u.user_id = a.user_id
ORDER BY u.user_id, a.acc_id;

list accounts with their type and addresses, keeping accounts even if no address exists
SELECT
  a.*,
  t.*,
  addr.*
FROM accounts a
LEFT JOIN account_type t
  ON a.type_id = t.type_id
LEFT JOIN addresses addr
  ON a.acc_id = addr.acc_id
ORDER BY a.acc_id;

list categories with their subcategories; keep parents even if no child exists
SELECT
  p.cat_id   AS parent_cat_id,
  p.cat_name AS parent_cat_name,
  c.cat_id   AS child_cat_id,
  c.cat_name AS child_cat_name
FROM categories p
LEFT JOIN categories c
  ON c.cat_parentid = p.cat_id
ORDER BY p.cat_id, c.cat_id;

list products where the number of reviews is greater than 10
SELECT p.prod_id,
       p.prod_name,
       COUNT(r.rev_id) AS review_count
FROM products p
JOIN reviews r
  ON p.prod_id = r.prod_id
GROUP BY p.prod_id, p.prod_name
HAVING COUNT(r.rev_id) > 10
ORDER BY review_count DESC;

find users who are in the set of active sessions
SELECT
  u.user_id AS id,
  u.user_username AS username
FROM users u
WHERE u.user_id IN (
  SELECT s.user_id
  FROM sessions s
  WHERE s.ses_createdat > CURRENT_TIMESTAMP
)
ORDER BY u.user_id;

list products whose category is itself a child of another category
SELECT
  p.prod_id,
  p.prod_name,
  p.cat_id AS child_cat_id,
  c.cat_name AS child_cat_name,
  c.cat_parentid AS parent_cat_id,
  parent.cat_name AS parent_cat_name
FROM products p
JOIN categories c
  ON p.cat_id = c.cat_id
JOIN categories parent
  ON c.cat_parentid = parent.cat_id
ORDER BY p.prod_id;

list active accounts joined to active users, using a subquery instead of the full users table
SELECT
  a.acc_id,
  a.user_id,
  a.acc_startdate,
  a.acc_isactive,
  au.user_username,
  au.user_email
FROM accounts a
JOIN (
  SELECT user_id, user_username, user_email
  FROM users
  WHERE user_isactive = 'Y'
) au
  ON a.user_id = au.user_id
WHERE a.acc_isactive = 'Y'
ORDER BY a.acc_id;
